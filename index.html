<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color & Shape Match Study</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use the Inter font family -->
    <style>
        @import url('https://fonts.fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; 
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        /* Adjusted container width for better responsiveness on smaller screens */
        .game-container {
            width: 95%; /* Use more width on mobile */
            max-width: 700px;
            background-color: white;
            box-shadow: 0 10px 35px rgba(0, 0, 0, 0.2);
            border-radius: 1.5rem;
            overflow: hidden;
            padding: 1rem;
        }
        canvas {
            display: block;
            border: 4px solid #3b82f6; 
            border-radius: 1rem;
            touch-action: none; 
        }
        .score-board {
            transition: transform 0.1s ease-out;
        }
        .score-board.flash {
            transform: scale(1.1);
            color: #10b981; 
        }
        .error-ring {
            box-shadow: 0 0 0 4px #ef4444; 
            animation: ring-pulse 0.5s;
        }
        @keyframes ring-pulse {
            0% { box-shadow: 0 0 0 4px #ef4444; }
            50% { box-shadow: 0 0 0 12px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 4px #ef4444; }
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            padding: 1rem; /* Add padding for small screens */
            box-sizing: border-box;
        }
        /* Crucial fix: make modal content responsive */
        .modal-content {
            width: 100%; 
            max-width: 550px; /* Adjusted max width */
            max-height: 95vh; /* Prevent modal from exceeding viewport height */
            overflow-y: auto; /* Allow scrolling if report is too long */
        }
        /* Custom styles for the error indicators */
        .error-dot {
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background-color: #e5e7eb; /* Light gray */
            border: 2px solid #9ca3af;
        }
        .error-dot.missed {
            background-color: #ef4444; /* Red */
            border-color: #b91c1c;
            animation: bounce 0.3s ease-in-out;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }
        .report-section {
            padding: 1rem;
            border-radius: 0.75rem;
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            margin-top: 0.5rem;
        }
        .report-title {
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 0.5rem;
            display: block;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.25rem;
        }
    </style>
</head>
<body>

<div class="game-container">
    <!-- Header/Score Board -->
    <div class="flex flex-col sm:flex-row justify-between items-center p-3 mb-4 bg-yellow-100 rounded-xl border-4 border-yellow-500">
        <h1 class="text-3xl font-extrabold text-blue-700 mb-2 sm:mb-0">Fun Match Study</h1>
        <div class="flex items-center space-x-4">
            <div id="high-score-board" class="text-xl font-bold text-gray-600">High Score: 0</div>
            <div id="difficulty-indicator" class="text-xl font-bold text-gray-600">Load: 7</div>
            <div id="score-board" class="score-board text-4xl font-black text-gray-800">Score: 0</div>
        </div>
    </div>

    <!-- Error/Misses Tracker -->
    <div class="flex justify-center space-x-2 mb-4">
        <div id="error-dot-1" class="error-dot"></div>
        <div id="error-dot-2" class="error-dot"></div>
        <div id="error-dot-3" class="error-dot"></div>
    </div>

    <!-- Instructions/Target Prompt -->
    <div id="prompt-box" class="p-3 mb-4 text-center bg-purple-100 rounded-xl border-4 border-purple-500">
        <p class="text-xl font-semibold text-purple-800">Your Goal:</p>
        <div id="target-prompt" class="text-5xl font-extrabold text-red-600 mt-2">
            Initializing...
        </div>
    </div>

    <!-- Game Canvas -->
    <canvas id="game-canvas" width="650" height="400"></canvas>

    <!-- Control Button -->
    <div class="mt-4 text-center">
        <button id="start-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-full shadow-lg transition duration-200 transform hover:scale-105 active:scale-95 text-xl">
            Start Game!
        </button>
    </div>
</div>

<!-- Game Over Modal (Hidden by default) -->
<div id="game-over-modal" class="modal-overlay hidden">
    <div class="modal-content bg-white p-6 sm:p-10 rounded-2xl shadow-2xl transform transition-all scale-100">
        <h2 class="text-4xl font-black text-red-600 mb-4 text-center">Game Over!</h2>
        
        <div class="flex justify-around text-center mb-6 border-b pb-4">
            <div>
                <p class="text-lg text-gray-600">Final Score</p>
                <p id="modal-final-score" class="text-5xl font-extrabold text-blue-700">0</p>
            </div>
            <div>
                <p class="text-lg text-gray-600">High Score</p>
                <p id="modal-high-score" class="text-3xl font-bold text-yellow-600">0</p>
            </div>
        </div>

        <h3 class="text-xl font-bold text-gray-800 mb-3">Behavioral Analysis Report:</h3>
        <div id="analysis-report" class="text-gray-700 space-y-3 text-sm bg-gray-50 p-4 rounded-lg">
            <!-- Analysis results will be inserted here -->
        </div>
        
        <p id="new-high-score-message" class="text-center mt-4 text-2xl font-bold text-green-600 hidden">⭐ New High Score! ⭐</p>

        <button id="restart-button" class="mt-6 w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 rounded-full shadow-lg transition duration-200 text-xl">
            Play Again
        </button>
        <p id="user-id-display" class="mt-3 text-xs text-center text-gray-400">User ID: N/A</p>
    </div>
</div>

<script type="module">
    // --- Firebase Imports ---
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- Firebase/Auth Setup ---
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfigStr = typeof __firebase_config !== 'undefined' ? __firebase_config : '{}';
    const firebaseConfig = JSON.parse(firebaseConfigStr);

    let app;
    let db;
    let auth;
    let userId = null;
    let isAuthReady = false;

    // Initialize Firebase
    try {
        app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);
    } catch (e) {
        console.error("Firebase initialization failed:", e);
        targetPromptEl.textContent = "Error: DB failed to load.";
    }

    // Handle Authentication
    onAuthStateChanged(auth, async (user) => {
        if (user) {
            userId = user.uid;
            document.getElementById('user-id-display').textContent = `User ID: ${userId}`;
            isAuthReady = true;
            console.log("Authentication successful. User ID:", userId);
            loadHighScore();
            targetPromptEl.textContent = 'Click "Start Game!" to begin.';
        } else {
            // Sign in anonymously if no token is available or user is signed out
            try {
                if (typeof __initial_auth_token !== 'undefined') {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Authentication failed:", error);
                targetPromptEl.textContent = "Error: Auth failed. Check console.";
            }
        }
    });

    // --- DOM Elements ---
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    const targetPromptEl = document.getElementById('target-prompt');
    const scoreBoardEl = document.getElementById('score-board');
    const highScoreBoardEl = document.getElementById('high-score-board');
    const difficultyIndicatorEl = document.getElementById('difficulty-indicator'); 
    const startButton = document.getElementById('start-button');
    const modal = document.getElementById('game-over-modal');
    const restartButton = document.getElementById('restart-button');
    const analysisReportEl = document.getElementById('analysis-report');
    const errorDots = [
        document.getElementById('error-dot-1'),
        document.getElementById('error-dot-2'),
        document.getElementById('error-dot-3')
    ];

    // --- Game Configuration & State (Updated for Adaptive Difficulty) ---
    const SHAPE_SIZE = 40; 
    const HIT_RADIUS_MULTIPLIER = 2.2; 
    const MIN_SEPARATION = SHAPE_SIZE * 3.5; 
    const MAX_PLACEMENT_ATTEMPTS = 30; 
    const MAX_MISSES = 3;
    const COLORS = { Red: '#ef4444', Blue: '#3b82f6', Green: '#10b981', Yellow: '#f59e0b', Orange: '#f97316', Cyan: '#06b6d4', Pink: '#ec4899', Brown: '#845415' };
    const SHAPES = ['Circle', 'Square', 'Triangle', 'Star'];

    // --- ADAPTIVE DIFFICULTY CONSTANTS ---
    const MIN_SHAPE_COUNT = 5;
    const MAX_SHAPE_COUNT = 10;
    const RECENT_ROUNDS_FOR_ADJUSTMENT = 5;
    const ACCURACY_THRESHOLD_UP = 0.85; // 85% accuracy needed to increase difficulty
    const RT_THRESHOLD_UP = 2000;       // Faster than 2000ms needed to increase difficulty
    const ACCURACY_THRESHOLD_DOWN = 0.60; // Below 60% accuracy triggers difficulty decrease
    const RT_THRESHOLD_DOWN = 3500;     // Slower than 3500ms triggers difficulty decrease
    // -------------------------------------

    let score = 0;
    let misses = 0;
    let highScore = 0;
    let target = { color: '', shape: '' };
    let activeShapes = [];
    let isGameRunning = false;
    let clickTimeout = null;
    let roundStartTime = 0; 
    let sessionLog = []; 
    let currentShapeCount = 7; // Initial difficulty level

    // Adjust canvas size for responsiveness
    function resizeCanvas() {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth - 30; 
        canvas.height = Math.min(window.innerHeight * 0.6, 450); 
        if (isGameRunning) drawGame();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); // Initial call

    // --- Firestore Functions ---

    function getUserDocRef() {
        if (!isAuthReady || !userId) return null;
        // Path: /artifacts/{appId}/users/{userId}/game_data/study_data
        return doc(db, 'artifacts', appId, 'users', userId, 'game_data', 'study_data');
    }

    async function loadHighScore() {
        const userDocRef = getUserDocRef();
        if (!userDocRef) return;
        try {
            const docSnap = await getDoc(userDocRef);
            if (docSnap.exists()) {
                highScore = docSnap.data().highScore || 0;
                highScoreBoardEl.textContent = `High Score: ${highScore}`;
            }
        } catch (e) {
            console.error("Error loading high score:", e);
        }
    }

    async function saveHighScore(newScore) {
        const userDocRef = getUserDocRef();
        if (!userDocRef) return false;
        if (newScore > highScore) {
            try {
                // Use setDoc with merge: true to update only the high score field
                await setDoc(userDocRef, { highScore: newScore }, { merge: true });
                highScore = newScore;
                highScoreBoardEl.textContent = `High Score: ${highScore}`;
                return true;
            } catch (e) {
                console.error("Error saving high score:", e);
                return false;
            }
        }
        return false;
    }

    async function saveSession(logData) {
        const userDocRef = getUserDocRef();
        if (!userDocRef) return;

        // Path: /artifacts/{appId}/users/{userId}/sessions/{timestamp}
        const sessionDocRef = doc(db, 'artifacts', appId, 'users', userId, 'sessions', Date.now().toString());

        try {
            await setDoc(sessionDocRef, {
                timestamp: Date.now(),
                score: logData.score,
                misses: logData.misses,
                duration: logData.duration,
                log: logData.log,
                analysis: logData.analysis,
                appId: appId
            });
            console.log("Session data saved to Firestore.");
        } catch (e) {
            console.error("Error saving session data:", e);
        }
    }


    // --- Game Logic ---

    function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
    function getRandom(arr) { return arr[randInt(0, arr.length - 1)]; }

    /** Determines which quadrant a coordinate (x, y) falls into. */
    function getQuadrant(x, y, w, h) {
        const centerX = w / 2;
        const centerY = h / 2;

        if (x < centerX && y < centerY) return 'TL'; // Top-Left
        if (x >= centerX && y < centerY) return 'TR'; // Top-Right
        if (x < centerX && y >= centerY) return 'BL'; // Bottom-Left
        if (x >= centerX && y >= centerY) return 'BR'; // Bottom-Right
        return 'Center';
    }


    /** Generates a single shape object with random properties (no position) */
    function createRandomShapeProps() {
        const colorName = getRandom(Object.keys(COLORS));
        const shapeType = getRandom(SHAPES);
        
        return {
            colorName: colorName,
            colorCode: COLORS[colorName],
            shape: shapeType,
            size: SHAPE_SIZE * (1 + Math.random() * 0.5) 
        };
    }
    
    /** Attempts to find a position for a new shape that does not collide with existing shapes. */
    function getNonCollidingPosition(existingShapes) {
        const padding = SHAPE_SIZE * 2;
        
        for (let attempt = 0; attempt < MAX_PLACEMENT_ATTEMPTS; attempt++) {
            // Generate a random position within the padded canvas bounds
            const x = randInt(padding, canvas.width - padding);
            const y = randInt(padding, canvas.height - padding);
            let collision = false;

            for (const shape of existingShapes) {
                const dx = x - shape.x;
                const dy = y - shape.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Collision occurs if distance is less than the minimum required separation
                if (distance < MIN_SEPARATION) {
                    collision = true;
                    break;
                }
            }

            if (!collision) {
                return { x, y };
            }
        }
        return null; // Failed to find a position after max attempts
    }
    
    /** Checks if a point (x, y) is inside the given shape, using a generous radius. */
    function isPointInShape(x, y, shape) {
        const dx = x - shape.x;
        const dy = y - shape.y;
        
        const hitRadius = shape.size * HIT_RADIUS_MULTIPLIER; 

        if (shape.shape === 'Square') {
            const side = shape.size * 1.8;
            const halfSide = side / 2;
            const buffer = (hitRadius - halfSide) / 2; 

            const xMin = shape.x - halfSide - buffer;
            const xMax = shape.x + halfSide + buffer;
            const yMin = shape.y - halfSide - buffer;
            const yMax = shape.y + halfSide + buffer;
            
            return x >= xMin && x <= xMax && y >= yMin && y <= yMax;
        } 
        
        return Math.sqrt(dx * dx + dy * dy) < hitRadius;
    }

    /** Generates the active shapes, ensuring exactly one matches the target */
    function generateActiveShapes() {
        activeShapes = [];
        // Use the current dynamic shape count
        const shapeCount = currentShapeCount;
        let foundTarget = false;

        // Set new target and log the start time for reaction time calculation
        target.color = getRandom(Object.keys(COLORS));
        target.shape = getRandom(SHAPES);
        target.quadrant = ''; // Reset target quadrant

        roundStartTime = Date.now();

        targetPromptEl.textContent = `Tap the ${target.color} ${target.shape}!`;
        targetPromptEl.style.color = COLORS[target.color];

        for (let i = 0; i < shapeCount; i++) {
            const position = getNonCollidingPosition(activeShapes);

            if (!position) {
                // Stop placing shapes if no safe spot can be found (e.g., canvas is full)
                console.warn(`Could not place all ${shapeCount} shapes without collision. Placed ${activeShapes.length}`);
                // If collision fails when the count is > MIN, reduce count for next round
                if (currentShapeCount > MIN_SHAPE_COUNT) {
                    currentShapeCount = Math.max(currentShapeCount - 1, MIN_SHAPE_COUNT);
                    console.log(`Reducing shape count to ${currentShapeCount} due to placement failure.`);
                }
                break; 
            }

            const newShapeProps = createRandomShapeProps();
            const newShape = {
                ...newShapeProps,
                x: position.x,
                y: position.y,
                shapeCount: shapeCount // Log the cognitive load level for this round
            };

            if (!foundTarget && i === randInt(0, shapeCount - 1)) {
                // Set this shape as the target
                newShape.colorName = target.color;
                newShape.colorCode = COLORS[target.color];
                newShape.shape = target.shape;
                foundTarget = true;
                target.quadrant = getQuadrant(newShape.x, newShape.y, canvas.width, canvas.height); // Log target quadrant
            } else if (newShape.colorName === target.color && newShape.shape === target.shape) {
                // Ensure no accidental duplicates of the target are created
                newShape.colorName = getRandom(Object.keys(COLORS).filter(c => c !== target.color));
                newShape.colorCode = COLORS[newShape.colorName];
            }
            activeShapes.push(newShape);
        }

        // Failsafe: if the loop missed placing the target, force it onto the last shape
        if (!foundTarget && activeShapes.length > 0) {
             const lastShape = activeShapes[activeShapes.length - 1];
             lastShape.colorName = target.color;
             lastShape.colorCode = COLORS[target.color];
             lastShape.shape = target.shape;
             foundTarget = true; // Mark as found after fixing
             target.quadrant = getQuadrant(lastShape.x, lastShape.y, canvas.width, canvas.height);
        } else if (!foundTarget && activeShapes.length === 0) {
            // If the canvas is too small to even place one shape, we need to handle this error state gracefully
             targetPromptEl.textContent = 'Error: Cannot fit shapes on screen.';
             isGameRunning = false;
        }

        drawGame();
        difficultyIndicatorEl.textContent = `Load: ${currentShapeCount}`; // Update UI difficulty
    }

    // --- Drawing Functions ---

    function drawCircle(x, y, size, color) {
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'rgba(0,0,0,0.3)';
        ctx.fill();
        ctx.closePath();
    }

    function drawSquare(x, y, size, color) {
        const side = size * 1.8;
        ctx.beginPath();
        const r = 10;
        ctx.moveTo(x + r - side/2, y - side/2);
        ctx.lineTo(x + side/2 - r, y - side/2);
        ctx.arcTo(x + side/2, y - side/2, x + side/2, y - side/2 + r, r);
        ctx.lineTo(x + side/2, y + side/2 - r);
        ctx.arcTo(x + side/2, y + side/2, x + side/2 - r, y + side/2, r);
        ctx.lineTo(x - side/2 + r, y + side/2);
        ctx.arcTo(x - side/2, y + side/2, x - side/2, y + side/2 - r, r);
        ctx.lineTo(x - side/2, y - side/2 + r);
        ctx.arcTo(x - side/2, y - side/2, x - side/2 + r, y - side/2, r);
        ctx.fillStyle = color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'rgba(0,0,0,0.3)';
        ctx.fill();
        ctx.closePath();
    }

    function drawTriangle(x, y, size, color) {
        const height = size * 2;
        const width = size * 2;
        ctx.beginPath();
        ctx.moveTo(x, y - height / 2); 
        ctx.lineTo(x + width / 2, y + height / 2); 
        ctx.lineTo(x - width / 2, y + height / 2); 
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'rgba(0,0,0,0.3)';
        ctx.fill();
    }

    function drawStar(x, y, size, color) {
        const spikes = 5;
        const outerRadius = size * 1.5;
        const innerRadius = size * 0.6;
        let rot = Math.PI / 2 * 3;
        let step = Math.PI / spikes;

        ctx.beginPath();
        ctx.shadowBlur = 10;
        ctx.shadowColor = 'rgba(0,0,0,0.3)';
        ctx.moveTo(x, y - outerRadius);

        for (let i = 0; i < spikes; i++) {
            ctx.lineTo(x + Math.cos(rot) * outerRadius, y + Math.sin(rot) * outerRadius);
            rot += step;
            ctx.lineTo(x + Math.cos(rot) * innerRadius, y + Math.sin(rot) * innerRadius);
            rot += step;
        }
        ctx.lineTo(x, y - outerRadius);
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
    }

    function drawShape(shape) {
        ctx.save();
        switch (shape.shape) {
            case 'Circle':
                drawCircle(shape.x, shape.y, shape.size, shape.colorCode);
                break;
            case 'Square':
                drawSquare(shape.x, shape.y, shape.size, shape.colorCode);
                break;
            case 'Triangle':
                drawTriangle(shape.x, shape.y, shape.size, shape.colorCode);
                break;
            case 'Star':
                drawStar(shape.x, shape.y, shape.size, shape.colorCode);
                break;
        }
        ctx.restore();
    }

    function drawGame() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#e5e7eb'; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        activeShapes.forEach(drawShape);
    }

    // --- Interaction Handlers ---

    function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;

        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    }

    function updateErrorDots() {
        errorDots.forEach((dot, index) => {
            if (index < misses) {
                dot.classList.add('missed');
            } else {
                dot.classList.remove('missed');
            }
        });
    }

    function handleClick(e) {
        if (!isGameRunning) return;
        
        e.preventDefault(); 
        const pos = getMousePos(e);
        const reactionTime = Date.now() - roundStartTime;

        // Check from last drawn shape (on top) backwards
        const clickedShape = activeShapes.slice().reverse().find(shape => {
            return isPointInShape(pos.x, pos.y, shape);
        });
        
        // Determine the quadrant where the user actually tapped
        const clickedQuadrant = getQuadrant(pos.x, pos.y, canvas.width, canvas.height);

        if (clickedShape) {
            const logEntry = {
                time: Date.now(),
                reactionTime: reactionTime,
                clickX: pos.x,
                clickY: pos.y,
                targetColor: target.color,
                targetShape: target.shape,
                targetQuadrant: target.quadrant, // Log target quadrant
                clickedColor: clickedShape.colorName,
                clickedShape: clickedShape.shape,
                clickedQuadrant: clickedQuadrant, // Log tap quadrant
                shapeCount: currentShapeCount
            };

            if (clickedShape.colorName === target.color && clickedShape.shape === target.shape) {
                // Correct match!
                score++;
                flashScore();
                logEntry.type = 'Correct';
                sessionLog.push(logEntry);
                generateNextRound();
            } else {
                // Wrong shape/color (Miss)
                misses++;
                updateErrorDots();
                shakeCanvas();
                logEntry.type = 'Miss';
                sessionLog.push(logEntry);

                if (misses >= MAX_MISSES) {
                    endGame();
                }
            }
        }
    }

    /** Visual feedback for correct answer */
    function flashScore() {
        scoreBoardEl.textContent = `Score: ${score}`;
        scoreBoardEl.classList.add('flash');
        setTimeout(() => {
            scoreBoardEl.classList.remove('flash');
        }, 300);
    }

    /** Visual feedback for incorrect answer */
    function shakeCanvas() {
        canvas.classList.add('error-ring');
        setTimeout(() => {
            canvas.classList.remove('error-ring');
        }, 500);
    }

    /** Analyzes recent performance and adjusts the number of shapes (distractors). */
    function adjustDifficulty() {
        // 1. Get the last N total attempts (correct and miss)
        const recentAttempts = sessionLog.slice(-RECENT_ROUNDS_FOR_ADJUSTMENT);

        if (recentAttempts.length < RECENT_ROUNDS_FOR_ADJUSTMENT) {
            // Not enough data yet
            return; 
        }

        const recentCorrectLogs = recentAttempts.filter(l => l.type === 'Correct');
        
        const recentAccuracy = recentCorrectLogs.length / recentAttempts.length;
        const recentRTs = recentCorrectLogs.map(l => l.reactionTime);
        const avgRecentRT = recentRTs.length > 0 ? recentRTs.reduce((a, b) => a + b, 0) / recentRTs.length : Infinity;

        let action = 'None';
        let newShapeCount = currentShapeCount;

        // Rule UP: High Accuracy AND Fast RT
        if (currentShapeCount < MAX_SHAPE_COUNT && recentAccuracy >= ACCURACY_THRESHOLD_UP && avgRecentRT <= RT_THRESHOLD_UP) {
            newShapeCount = currentShapeCount + 1;
            action = 'Increased';
        } 
        // Rule DOWN: Low Accuracy OR Very Slow RT
        else if (currentShapeCount > MIN_SHAPE_COUNT && (recentAccuracy < ACCURACY_THRESHOLD_DOWN || avgRecentRT > RT_THRESHOLD_DOWN)) {
            newShapeCount = currentShapeCount - 1;
            action = 'Decreased';
        }

        if (action !== 'None') {
             console.log(`Difficulty ${action} to ${newShapeCount} shapes (Acc: ${(recentAccuracy * 100).toFixed(0)}%, RT: ${avgRecentRT.toFixed(0)}ms, Current: ${currentShapeCount})`);
             currentShapeCount = newShapeCount;
        }
    }

    /** Starts a new round of the game */
    function generateNextRound() {
        if (clickTimeout) clearTimeout(clickTimeout);

        // Adjust difficulty before starting the next round
        adjustDifficulty(); 

        clickTimeout = setTimeout(() => {
            generateActiveShapes();
        }, 500);
    }

    // Helper function to calculate Standard Deviation
    function calculateStandardDeviation(array) {
        if (array.length === 0) return 0;
        const mean = array.reduce((a, b) => a + b, 0) / array.length;
        const variance = array.reduce((sum, value) => sum + (value - mean) ** 2, 0) / array.length;
        return Math.sqrt(variance);
    }


    /** Processes the session log and generates a simple behavioral report */
    function generateReport() {
        const totalAttempts = sessionLog.length;
        const correctTaps = sessionLog.filter(l => l.type === 'Correct').length;
        const totalMisses = sessionLog.filter(l => l.type === 'Miss').length; 
        const accuracy = totalAttempts > 0 ? ((correctTaps / totalAttempts) * 100).toFixed(0) : 0;
        
        const correctTimes = sessionLog.filter(l => l.type === 'Correct').map(l => l.reactionTime);
        const avgReactionTime = correctTimes.length > 0 ? (correctTimes.reduce((a, b) => a + b, 0) / correctTimes.length).toFixed(0) : 'N/A';
        const stDevReactionTime = calculateStandardDeviation(correctTimes).toFixed(0);

        // --- Error Analysis ---
        const errorDetails = sessionLog
            .filter(l => l.type === 'Miss');
        
        let colorErrorCount = 0;
        let shapeErrorCount = 0;
        const shapeConfusions = {}; // Tracks which shape was targeted vs. which was clicked
        const quadrantMisses = {}; // Tracks misses based on target quadrant
        
        errorDetails.forEach(l => {
            // Did they tap the correct color but the wrong shape?
            const isShapeError = l.targetColor === l.clickedColor && l.targetShape !== l.clickedShape;
            // Did they tap the correct shape but the wrong color?
            const isColorError = l.targetColor !== l.clickedColor && l.targetShape === l.clickedShape;
            
            if (isColorError && !isShapeError) {
                colorErrorCount++;
            } else if (isShapeError && !isColorError) {
                shapeErrorCount++;
            }
            
            // Track specific shape confusion (e.g., Target: Circle, Clicked: Square)
            if (l.targetShape !== l.clickedShape) {
                const confusionKey = `${l.targetShape} -> ${l.clickedShape}`;
                shapeConfusions[confusionKey] = (shapeConfusions[confusionKey] || 0) + 1;
            }
            
            // Track spatial misses
            quadrantMisses[l.targetQuadrant] = (quadrantMisses[l.targetQuadrant] || 0) + 1;
        });
        
        // General analysis of errors based on the required attribute
        const totalAttributeErrors = errorDetails.reduce((acc, l) => {
            const colorMatch = l.targetColor === l.clickedColor;
            const shapeMatch = l.targetShape === l.clickedShape;
            
            if (!colorMatch) acc.colorMisses++;
            if (!shapeMatch) acc.shapeMisses++;
            return acc;
        }, { colorMisses: 0, shapeMisses: 0 });

        const attributeDominance = totalAttributeErrors.colorMisses > totalAttributeErrors.shapeMisses 
            ? `Color recognition (Targeted color was wrong ${totalAttributeErrors.colorMisses} times)`
            : `Shape identification (Targeted shape was wrong ${totalAttributeErrors.shapeMisses} times)`;
            
        // Reaction Time Trend
        const halfPoint = Math.floor(correctTimes.length / 2);
        const firstHalfAvg = correctTimes.length > 0 ? (correctTimes.slice(0, halfPoint).reduce((a, b) => a + b, 0) / (halfPoint || 1)).toFixed(0) : 'N/A';
        const secondHalfAvg = correctTimes.length > halfPoint ? (correctTimes.slice(halfPoint).reduce((a, b) => a + b, 0) / (correctTimes.length - halfPoint)).toFixed(0) : 'N/A';

        let trendInsight = 'N/A';
        if (firstHalfAvg !== 'N/A' && secondHalfAvg !== 'N/A') {
            const first = parseFloat(firstHalfAvg);
            const second = parseFloat(secondHalfAvg);
            const difference = second - first;
            if (difference > 200) {
                trendInsight = `Worsened by ${difference}ms. Suggests potential fatigue or sustained attention challenge.`;
            } else if (difference < -200) {
                trendInsight = `Improved by ${Math.abs(difference)}ms. Suggests learning, practice effect, or adaptation.`;
            } else {
                trendInsight = `Stable (difference of ${difference}ms). Suggests consistent speed across the session.`;
            }
        }
        
        // Spatial Bias Analysis
        const quadrantNames = { 'TL': 'Top-Left', 'TR': 'Top-Right', 'BL': 'Bottom-Left', 'BR': 'Bottom-Right' };
        const totalQuadrantMisses = Object.values(quadrantMisses).reduce((a, b) => a + b, 0);
        let spatialBias = 'No significant spatial bias detected.';

        let maxQuadrant = null;
        if (totalQuadrantMisses > 0) {
             const maxMisses = Math.max(...Object.values(quadrantMisses));
             maxQuadrant = Object.keys(quadrantMisses).find(key => quadrantMisses[key] === maxMisses);
             if (maxMisses > totalQuadrantMisses / 2 && totalQuadrantMisses >= 2) { // Simple threshold for bias
                spatialBias = `A high number of misses (${maxMisses} / ${totalQuadrantMisses} total misses) occurred when the target was in the **${quadrantNames[maxQuadrant]}** quadrant.`;
             }
        }

        const maxCognitiveLoad = Math.max(...sessionLog.map(l => l.shapeCount || currentShapeCount));

        let reportHTML = '';
        
        // Section 1: Core Performance
        reportHTML += `<div class="report-section">
            <span class="report-title">Core Performance Metrics</span>
            <ul class="space-y-1">
                <li><span class="font-semibold">Total Attempts:</span> ${totalAttempts}</li>
                <li><span class="font-semibold">Accuracy:</span> ${accuracy}% (${correctTaps} correct / ${totalMisses} misses)</li>
                <li><span class="font-semibold">Avg. Reaction Time (Correct):</span> ${avgReactionTime} ms</li>
                <li><span class="font-semibold">Reaction Time Variability (StDev):</span> ${stDevReactionTime} ms. (Lower is better for focus)</li>
            </ul>
        </div>`;
        
        // Section 2: Error Attribution
        reportHTML += `<div class="report-section">
            <span class="report-title">Error Attribution Analysis</span>
            <ul class="space-y-1">
                <li><span class="font-semibold">Dominant Error Type:</span> ${attributeDominance}.</li>
                <li><span class="font-semibold">Pure Color Errors:</span> ${colorErrorCount} (Tapped correct shape, wrong color).</li>
                <li><span class="font-semibold">Pure Shape Errors:</span> ${shapeErrorCount} (Tapped correct color, wrong shape).</li>
            </ul>
        </div>`;
        
        // Section 3: Spatial and Specific Confusion
        reportHTML += `<div class="report-section">
            <span class="report-title">Spatial and Specific Confusion</span>
            <ul class="space-y-1">
                <li><span class="font-semibold">Cognitive Load Ceiling:</span> Session reached a maximum distractor count of **${maxCognitiveLoad}**.</li>
                <li><span class="font-semibold">Spatial Bias Detection:</span> ${spatialBias}</li>
                <li><span class="font-semibold">RT Trend:</span> ${trendInsight} (First Half Avg: ${firstHalfAvg}ms / Second Half Avg: ${secondHalfAvg}ms).</li>`;

        const mostConfusedShapeEntry = Object.entries(shapeConfusions).sort(([, a], [, b]) => b - a)[0];
        if (mostConfusedShapeEntry) {
            reportHTML += `<li><span class="font-semibold">Most Confused Pair:</span> ${mostConfusedShapeEntry[0]} (${mostConfusedShapeEntry[1]} times).</li>`;
        } else {
            reportHTML += `<li><span class="font-semibold">Specific Shape Confusion:</span> No specific shape confusion patterns detected.</li>`;
        }
        
        reportHTML += `</ul></div>`;
        
        // Section 4: Developmental Interpretation (NEW)
        reportHTML += `<div class="report-section bg-red-50">
            <span class="report-title text-red-700">Interpretive Summary (Medical Focus)</span>
            <ul class="space-y-1 text-red-800">
                <li><span class="font-bold">Attention/Processing (Thinking):</span> The high Reaction Time Variability (StDev: ${stDevReactionTime}ms) suggests the child's processing speed is **${stDevReactionTime > 500 ? 'highly inconsistent' : 'consistent'}**, which can be an indicator of fluctuating attention or focus issues.</li>
                <li><span class="font-bold">Visual/Spatial Acuity (Eyesight):</span> The spatial analysis suggests **${spatialBias.includes('high number') ? `a localized challenge in the ${quadrantNames[maxQuadrant]} visual field` : 'consistent visual attention across the screen'}**. A high number of misses in one quadrant may warrant further clinical assessment for spatial neglect or visual field defects.</li>
                <li><span class="font-bold">Cognitive Capacity:</span> The child successfully managed a maximum distractor load of **${maxCognitiveLoad}**. If this number is low (e.g., 5 or 6), it suggests a low attentional capacity or quick cognitive fatigue.</li>
                <li><span class="font-bold">Discrimination Skill:</span> The breakdown in **Error Attribution** highlights whether the child is struggling more with **color discrimination** or **shape recognition**, which guides where focused intervention might be needed.</li>
            </ul>
            <p class="text-xs mt-3 text-red-600 font-semibold">Disclaimer: This summary is based on game metrics only and is not a medical diagnosis. Consult a qualified professional for clinical interpretation.</p>
        </div>`;

        
        return { reportHTML, totalRounds: totalAttempts, totalMisses };
    }


    /** Ends the current game session */
    async function endGame() {
        isGameRunning = false;
        
        if (clickTimeout) clearTimeout(clickTimeout);
        
        // 1. Generate Report
        const { reportHTML, totalRounds, totalMisses } = generateReport();
        analysisReportEl.innerHTML = reportHTML;

        // 2. Save High Score
        const newHighScore = await saveHighScore(score);

        // 3. Update Modal UI
        document.getElementById('modal-final-score').textContent = score;
        document.getElementById('modal-high-score').textContent = highScore;
        
        if (newHighScore) {
            document.getElementById('new-high-score-message').classList.remove('hidden');
        } else {
            document.getElementById('new-high-score-message').classList.add('hidden');
        }

        // 4. Save Session Log to Firestore
        const sessionDuration = sessionLog.length > 0 ? (sessionLog[sessionLog.length - 1].time - sessionLog[0].time) : 0;
        
        // Collect a simplified analysis summary for the database
        const analysisSummary = {
            totalRounds, 
            correctTaps: score, 
            totalMisses, 
            accuracy: (score / totalRounds) * 100,
            avgRT: parseFloat(generateReport().avgReactionTime || 0),
            stDevRT: parseFloat(generateReport().stDevReactionTime || 0),
            maxLoad: Math.max(...sessionLog.map(l => l.shapeCount || currentShapeCount))
        };
        
        await saveSession({
            score: score,
            misses: totalMisses,
            duration: sessionDuration,
            log: sessionLog, // Raw log for detailed analysis
            analysis: analysisSummary // Summarized analysis for quick query
        });

        // 5. Show Modal
        modal.classList.remove('hidden');
    }

    /** Initialization function */
    function startGame() {
        if (!isAuthReady) {
            targetPromptEl.textContent = "Hold on, setting up connection...";
            return;
        }

        // Reset all session variables
        score = 0;
        misses = 0;
        sessionLog = [];
        roundStartTime = 0;
        isGameRunning = true;
        currentShapeCount = 7; // Reset difficulty to default level
        
        scoreBoardEl.textContent = 'Score: 0';
        updateErrorDots();

        // UI updates
        difficultyIndicatorEl.textContent = `Load: ${currentShapeCount}`;
        startButton.textContent = 'Playing...';
        startButton.disabled = true;
        startButton.classList.replace('bg-green-500', 'bg-gray-400');
        startButton.classList.remove('hover:bg-green-600', 'hover:scale-105', 'active:scale-95');
        modal.classList.add('hidden'); // Hide modal if it was showing
        document.getElementById('prompt-box').classList.remove('border-red-600');
        document.getElementById('prompt-box').classList.add('border-purple-500');

        generateNextRound();
    }

    // --- Event Listeners ---
    startButton.addEventListener('click', startGame);
    restartButton.addEventListener('click', startGame);
    canvas.addEventListener('mousedown', handleClick);
    canvas.addEventListener('touchstart', handleClick, { passive: false }); 

    // Initial message before start
    targetPromptEl.textContent = 'Waiting for secure session...';
</script>

</body>
</html>
